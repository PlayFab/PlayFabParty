// This script generates consts, enums, and structs in Party_c.h from their declarations in Party.h, converting between
// C++-style and C-style declarations. It also generates C_ASSERTs in PartyImpl.h to verify  that all types are
// compatible.
//
// Usage: csi .\UpdateHeaders.csx

#load "AutoGenerate.csx" // UpdateAutoGeneratedSection

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

using System.Runtime.CompilerServices;
static string GetScriptDirectory([CallerFilePath] string path = "")
{
    return Path.GetDirectoryName(path);
}

enum Mode
{
    Global,
    Enum,
    Struct
}

class CppConst
{
    public string name;
    public long value;
    public bool hex;
}

class CppEnum
{
    public string name;
    public string type;
    public List<CppEnumValue> values;
    public bool hex;
}

class CppEnumValue
{
    public string name;
    public long value;
    public string line;
}

class CppStruct
{
    public string name;
    public bool stateChange;
    public List<CppStructField> fields;
}

enum PointerType
{
    None,
    Single,
    ConstStar,
    ConstStarStar,
    ConstStarConstStar
}

class ParsedCppHeader
{
    public List<CppEnum> cppEnums = new List<CppEnum>();
    public List<CppConst> cppConsts = new List<CppConst>();
    public List<CppStruct> cppStructs = new List<CppStruct>();

    public bool isXblPlugin = false;
}

class CppStructField
{
    public string name;
    public string type;
    public string annotation;
    public string sizeName;
    public bool array;
    public string arraySize;
    public PointerType pointerType;
    public string line;
}

public class Program
{
    // configuration
    readonly string[] _passThruTypes = new string[]
    {
        "void",
        "char",
        "float",
        "wchar_t",
        "size_t",
        "uint8_t",
        "int8_t",
        "uint16_t",
        "int16_t",
        "int32_t",
        "uint32_t",
        "int64_t",
        "uint64_t",
        "PartyError",
        "PartyBool",
        "PartyString",
    };

    readonly HashSet<string> _handleTypes = new HashSet<string>()
    {
        "PARTY_ENDPOINT_HANDLE",
        "PARTY_DEVICE_HANDLE",
        "PARTY_NETWORK_HANDLE",
        "PARTY_CHAT_CONTROL_HANDLE",
        "PARTY_LOCAL_USER_HANDLE",
        "PARTY_XBL_HANDLE",
        "PARTY_XBL_CHAT_USER_HANDLE",
        "PARTY_INVITATION_HANDLE",
    };

    readonly Dictionary<string, string> _convertedTypes = new Dictionary<string, string>()
    {
        { "PartyStateChangeType", "uint32_t" },
        { "PartyXblStateChangeType", "uint32_t" }
    };

    readonly Dictionary<string, string> _handlesForPointerTypes = new Dictionary<string, string>()
    {
        { "PartyEndpoint", "PARTY_ENDPOINT_HANDLE" },
        { "PartyLocalEndpoint", "PARTY_ENDPOINT_HANDLE" },
        { "PartyDevice", "PARTY_DEVICE_HANDLE" },
        { "PartyLocalDevice", "PARTY_DEVICE_HANDLE" },
        { "PartyInvitation", "PARTY_INVITATION_HANDLE" },
        { "PartyNetwork", "PARTY_NETWORK_HANDLE" },
        { "PartyChatControl", "PARTY_CHAT_CONTROL_HANDLE" },
        { "PartyLocalChatControl", "PARTY_CHAT_CONTROL_HANDLE" },
        { "PartyLocalUser", "PARTY_LOCAL_USER_HANDLE" },
        { "PartyXblLocalChatUser", "PARTY_XBL_CHAT_USER_HANDLE" },
        { "PartyXblChatUser", "PARTY_XBL_CHAT_USER_HANDLE"},
    };

    readonly Dictionary<string, string> _handlesForPointerArrayTypes = new Dictionary<string, string>()
    {
        { "PartyEndpointArray", "PARTY_ENDPOINT_HANDLE" },
        { "PartyLocalEndpointArray", "PARTY_ENDPOINT_HANDLE" },
        { "PartyDeviceArray", "PARTY_DEVICE_HANDLE" },
        { "PartyLocalDeviceArray", "PARTY_DEVICE_HANDLE" },
        { "PartyInvitationArray", "PARTY_INVITATION_HANDLE" },
        { "PartyNetworkArray", "PARTY_NETWORK_HANDLE" },
        { "PartyChatControlArray", "PARTY_CHAT_CONTROL_HANDLE" },
        { "PartyLocalChatControlArray", "PARTY_CHAT_CONTROL_HANDLE" },
        { "PartyLocalUserArray", "PARTY_LOCAL_USER_HANDLE" },
    };

    static string ConvertConstName(string cppName)
    {
        if (!cppName.StartsWith("c_"))
        {
            throw new Exception($"Unexpected constant name format {cppName}");
        }

        return "PARTY_" + ConvertMixedCaseToShoutCase(cppName.Substring(2));
    }

    static string ConvertEnumName(string enumClassName, string enumValueName)
    {
        return ConvertMixedCaseToShoutCase(enumClassName) + "_" + ConvertMixedCaseToShoutCase(enumValueName);
    }

    static string ConvertFieldName(string cppName)
    {
        return cppName;
    }

    static string ConvertAnnotationParameterName(string cppName)
    {
        // If initial substring is c_, assume a cpp constant
        if (cppName.StartsWith("c_"))
        {
            return ConvertConstName(cppName);
        }
        // If the first character is a number, verify the rest of the characters can be parsed as a valid integer constant
        else if (Char.IsNumber(cppName, 0))
        {
            if (cppName.StartsWith("0x"))
            {
                if (!long.TryParse(cppName, System.Globalization.NumberStyles.HexNumber, null, out _))
                {
                    throw new Exception($"Failed to parse hex value from \"{cppName}\".");
                }
            }
            else
            {
                if (!long.TryParse(cppName, out _))
                {
                    throw new Exception($"Failed to parse value from \"{cppName}\".");
                }
            }

            return cppName;
        }
        else
        {
            return ConvertFieldName(cppName);
        }
    }

    static string ConvertMixedCaseToShoutCase(string identifier)
    {
        string structNameWithUnderscores = string.Concat(identifier.Select((x,i) => i > 0 && char.IsUpper(x) ? "_" + x.ToString() : x.ToString()));
        return structNameWithUnderscores.ToUpper();
    }

    static string ConvertStateChangeCStructNameToTypeName(string cStructName)
    {
        Console.WriteLine(cStructName);
        if (cStructName.StartsWith("PARTY_XBL"))
        {
            return cStructName.Replace("_STATE_CHANGE", "").Replace("PARTY_XBL_", "PARTY_XBL_STATE_CHANGE_TYPE_");
        }
        else
        {
            return cStructName.Replace("_STATE_CHANGE", "").Replace("PARTY_", "PARTY_STATE_CHANGE_TYPE_");
        }
    }

    static string ConvertStateChangeCStructNameToUnionMemberName(string cStructName)
    {
        StringBuilder camelCase = new StringBuilder();
        bool upperCaseChar = false;
        String structPrefix = cStructName.StartsWith("PARTY_XBL") ? "party_xbl_" : "party_";
        foreach (var c in cStructName.ToLower().Replace(structPrefix, "").Replace("_state_change", ""))
        {
            if (c == '_')
            {
                upperCaseChar = true;
                continue;
            }

            camelCase.Append(upperCaseChar ? char.ToUpper(c) : c);
            upperCaseChar = false;
        }
        return camelCase.ToString();
    }

    string ConvertFieldType(string type)
    {
        if (_handlesForPointerTypes.ContainsKey(type) || _handlesForPointerArrayTypes.ContainsKey(type))
        {
            // handle conversion must be done before calling this method
            throw new Exception($"Unhandled special type: {type}");
        }

        if (_passThruTypes.Contains(type))
        {
            return type;
        }

        if (_convertedTypes.ContainsKey(type))
        {
            return $"{_convertedTypes[type]} /*{type.ToUpper()}*/";
        }

        return ConvertMixedCaseToShoutCase(type);
    }

    ParsedCppHeader ParseCppHeader(string fileName)
    {
        ParsedCppHeader parsedHeader = new ParsedCppHeader();

        CppEnum currCppEnum = null;
        long currCppEnumValue = 0;
        CppStruct currCppStruct = null;

        var lines = File.ReadAllLines(fileName);
        var mode = Mode.Global;
        foreach (var line in lines)
        {
            switch (mode)
            {
                case Mode.Global:
                {
                    // check for a constant
                    var match = Regex.Match(line, @"^constexpr (\w+) (\w+) = ([^;]+);");
                    if (match.Success)
                    {
                        var c = new CppConst
                        {
                            name = match.Groups[2].Value
                        };

                        var valueStr = match.Groups[3].Value;
                        if (valueStr.StartsWith("0x"))
                        {
                            valueStr = valueStr.Substring(2);
                            c.hex = true;

                            if (!long.TryParse(valueStr, System.Globalization.NumberStyles.HexNumber, null, out c.value))
                            {
                                throw new Exception($"Failed to parse hex value from \"{valueStr}\". Line: {line}");
                            }
                        }
                        else
                        {
                            if (!long.TryParse(valueStr, out c.value))
                            {
                                throw new Exception($"Failed to parse value from \"{valueStr}\". Line: {line}");
                            }
                        }

                        parsedHeader.cppConsts.Add(c);
                    }

                    // check for an enum
                    match = Regex.Match(line, @"^enum class (\w+)(?:\ : )?(\w+)?");
                    if (match.Success)
                    {
                        currCppEnum = new CppEnum
                        {
                            name = match.Groups[1].Value,
                            type = match.Groups[2].Value,
                            values = new List<CppEnumValue>()
                        };
                        currCppEnumValue = 0;
                        mode = Mode.Enum;
                    }

                    // check for a struct
                    match = Regex.Match(line, @"^struct (\w+)(?:\ : )?(\w+)?");
                    if (match.Success)
                    {
                        var superStruct = match.Groups[2].Value;
                        currCppStruct = new CppStruct
                        {
                            name = match.Groups[1].Value,
                            fields = new List<CppStructField>()
                        };

                        if (superStruct == "PartyStateChange" || superStruct == "PartyXblStateChange")
                        {
                            currCppStruct.stateChange = true;
                        }
                        else if (superStruct.Length > 0)
                        {
                            throw new Exception($"Unexpected struct inheritance. Line: {line}");
                        }
                        mode = Mode.Struct;
                    }

                    break;
                }

                case Mode.Enum:
                {
                    if (line == "};")
                    {
                        parsedHeader.cppEnums.Add(currCppEnum);
                        mode = Mode.Global;
                    }
                    else
                    {
                        var match = Regex.Match(line, @"^\s+(\w+)(?: = )?(\w+)?,");
                        if (match.Success)
                        {
                            var valueStr = match.Groups[2].Value;
                            if (valueStr.Length > 0)
                            {
                                if (valueStr.StartsWith("0x"))
                                {
                                    valueStr = valueStr.Substring(2);
                                    currCppEnum.hex = true;

                                    if (!long.TryParse(valueStr, System.Globalization.NumberStyles.HexNumber, null, out currCppEnumValue))
                                    {
                                        throw new Exception($"Failed to parse hex value from \"{valueStr}\". Line: {line}");
                                    }
                                }
                                else
                                {
                                    throw new Exception($"Enums should not have explicit value! Line: {line}");
                                }
                            }
                            var cppEnumValue = new CppEnumValue
                            {
                                name = match.Groups[1].Value,
                                value = currCppEnumValue,
                                line = line
                            };
                            currCppEnum.values.Add(cppEnumValue);
                            currCppEnumValue++;
                        }
                    }
                    break;
                }

                case Mode.Struct:
                {
                    if (line == "};")
                    {
                        parsedHeader.cppStructs.Add(currCppStruct);
                        mode = Mode.Global;
                    }
                    else
                    {
                        if (line.Length == 0 || line.StartsWith("    ///") || line == "{")
                        {
                            // line that can be ignored
                            break;
                        }

                        var cppField = new CppStructField
                        {
                            line = line
                        };
                        var decl = line;

                        var match = Regex.Match(decl, @"^\s+_Maybenull_ ");
                        if (match.Success)
                        {
                            cppField.annotation = "_Maybenull_ ";
                            decl = decl.Substring(match.Length);
                        }

                        match = Regex.Match(decl, @"^\s+_Field_range_\((\w+), (\w+)\) ");
                        if (match.Success)
                        {
                            var lowName = ConvertAnnotationParameterName(match.Groups[1].Value);
                            var highName = ConvertAnnotationParameterName(match.Groups[2].Value);
                            cppField.annotation = $"_Field_range_({lowName}, {highName}) ";
                            decl = decl.Substring(match.Length);
                        }

                        match = Regex.Match(decl, @"^\s+_Field_size_bytes_\((\w+)\) ");
                        if (match.Success)
                        {
                            var sizeName = ConvertAnnotationParameterName(match.Groups[1].Value);
                            cppField.annotation = $"_Field_size_bytes_({sizeName}) ";
                            decl = decl.Substring(match.Length);
                        }

                        match = Regex.Match(decl, @"^\s+_Field_size_\((\w+)\) ");
                        if (match.Success)
                        {
                            var sizeName = ConvertAnnotationParameterName(match.Groups[1].Value);
                            cppField.annotation = $"_Field_size_({sizeName}) ";
                            cppField.sizeName = sizeName;
                            decl = decl.Substring(match.Length);
                        }

                        match = Regex.Match(decl, @"^\s+_When_\((.+)\) ");
                        if (match.Success)
                        {
                            var sizeName = ConvertAnnotationParameterName(match.Groups[1].Value);
                            cppField.annotation = $"_When_({sizeName}) ";
                            cppField.sizeName = sizeName;
                            decl = decl.Substring(match.Length);
                        }

                        match = Regex.Match(decl, @"^\s*(\w+) (\w+);");
                        if (match.Success)
                        {
                            // simple type (or special array)
                            var type = match.Groups[1].Value;
                            var name = match.Groups[2].Value;
                            if (_handlesForPointerArrayTypes.ContainsKey(type))
                            {
                                cppField.pointerType = PointerType.Single;
                                cppField.type = _handlesForPointerArrayTypes[type];
                                cppField.name = name;
                            }
                            else
                            {
                                cppField.type = ConvertFieldType(type);
                                cppField.name = name;
                            }

                            currCppStruct.fields.Add(cppField);
                            break;
                        }

                        match = Regex.Match(decl, @"^\s*(\w+) \* (\w+);");
                        if (match.Success)
                        {
                            // simple pointer (or handle)
                            var type = match.Groups[1].Value;
                            var name = match.Groups[2].Value;
                            if (_handlesForPointerTypes.ContainsKey(type))
                            {
                                cppField.type = _handlesForPointerTypes[type];
                                cppField.name = name;
                            }
                            else
                            {
                                cppField.pointerType = PointerType.Single;
                                cppField.type = ConvertFieldType(type);
                                cppField.name = name;
                            }

                            currCppStruct.fields.Add(cppField);
                            break;
                        }

                        match = Regex.Match(decl, @"^\s*const (\w+) \* (\w+);");
                        if (match.Success)
                        {
                            // const pointer
                            var type = ConvertFieldType(match.Groups[1].Value);
                            var name = match.Groups[2].Value;
                            cppField.pointerType = PointerType.ConstStar;
                            cppField.type = type;
                            cppField.name = name;
                            currCppStruct.fields.Add(cppField);
                            break;
                        }

                        match = Regex.Match(decl, @"^\s*const (\w+) \*\* (\w+);");
                        if (match.Success)
                        {
                            // complicated pointer
                            var type = ConvertFieldType(match.Groups[1].Value);
                            var name = match.Groups[2].Value;
                            cppField.pointerType = PointerType.ConstStarStar;
                            cppField.type = type;
                            cppField.name = name;
                            currCppStruct.fields.Add(cppField);
                            break;
                        }

                        match = Regex.Match(decl, @"^\s*const (\w+) \* const \* (\w+);");
                        if (match.Success)
                        {
                            // complicated pointer
                            var type = ConvertFieldType(match.Groups[1].Value);
                            var name = match.Groups[2].Value;
                            cppField.pointerType = PointerType.ConstStarConstStar;
                            cppField.type = type;
                            cppField.name = name;
                            currCppStruct.fields.Add(cppField);
                            break;
                        }

                        match = Regex.Match(decl, @"^\s*(\w+) (\w+)\[(\w+)(?<nullterminator> \+ 1)?\];");
                        if (match.Success)
                        {
                            // null terminated buffer
                            var type = ConvertFieldType(match.Groups[1].Value);
                            var name = match.Groups[2].Value;
                            var size = ConvertConstName(match.Groups[3].Value);
                            if (!String.IsNullOrEmpty(match.Groups["nullterminator"].Value))
                            {
                                size += " + 1";
                            }
                            cppField.array = true;
                            cppField.type = type;
                            cppField.name = name;
                            cppField.arraySize = size;
                            currCppStruct.fields.Add(cppField);
                            break;
                        }

                        throw new Exception($"Unhandled struct declaration. Line: {line}");
                    }
                    break;
                }
            }
        }
        return parsedHeader;
    }

    List<string> ProcessHeaderForDeclarations(ParsedCppHeader parsedHeader)
    {
        var declarations = new List<string>();
        declarations.Add("");

        foreach (var c in parsedHeader.cppConsts)
        {
            var cName = ConvertConstName(c.name);
            if (c.hex)
            {
                declarations.Add($"#define {cName} 0x{c.value:x8}");
            }
            else
            {
                declarations.Add($"#define {cName} {c.value}");
            }
        }

        if (parsedHeader.cppConsts.Count > 0)
        {
            declarations.Add("");
        }

        string finalStateChangeTypeCValueName = "";
        foreach (var e in parsedHeader.cppEnums)
        {
            var cEnumName = ConvertMixedCaseToShoutCase(e.name);
            declarations.Add($"typedef enum {cEnumName}");
            declarations.Add("{");

            foreach (var v in e.values)
            {
                var cValueName = ConvertEnumName(e.name, v.name);
                if (e.hex)
                {
                    declarations.Add($"    {cValueName} = 0x{v.value:x4},");
                }
                else
                {
                    declarations.Add($"    {cValueName},");
                }
            }

            declarations.Add($"}} {cEnumName};");
            declarations.Add("");
        }

        foreach (var s in parsedHeader.cppStructs)
        {
            var cStructName = ConvertMixedCaseToShoutCase(s.name);
            var unionMemberName = ConvertStateChangeCStructNameToUnionMemberName(cStructName);
            declarations.Add($"typedef struct {cStructName}");
            declarations.Add("{");
            if (s.stateChange)
            {
                declarations.Add("    PARTY_STATE_CHANGE stateChange;");
            }

            foreach (var f in s.fields)
            {
                var cFieldName = ConvertFieldName(f.name);
                if (f.array)
                {
                    declarations.Add($"    {f.annotation}{f.type} {cFieldName}[{f.arraySize}];");
                }
                else
                {
                    switch (f.pointerType)
                    {
                        case PointerType.None:
                            declarations.Add($"    {f.annotation}{f.type} {cFieldName};");
                            break;
                        case PointerType.Single:
                            declarations.Add($"    {f.annotation}{f.type}* {cFieldName};");
                            break;
                        case PointerType.ConstStar:
                            declarations.Add($"    {f.annotation}const {f.type}* {cFieldName};");
                            break;
                        case PointerType.ConstStarStar:
                            declarations.Add($"    {f.annotation}const {f.type}** {cFieldName};");
                            break;
                        case PointerType.ConstStarConstStar:
                            declarations.Add($"    {f.annotation}const {f.type}*const* {cFieldName};");
                            break;

                        default:
                            throw new Exception($"Unhandled pointer type {f.pointerType}. Line: {f.line}");
                    }
                }
            }

            declarations.Add($"}} {cStructName};");
            declarations.Add("");
        }

        return declarations;
    }

    List<string> ProcessHeaderForCAsserts(ParsedCppHeader parsedHeader)
    {
        var casserts = new List<string>();
        casserts.Add("");

        foreach (var c in parsedHeader.cppConsts)
        {
            var cName = ConvertConstName(c.name);
            casserts.Add($"C_ASSERT({cName} == {c.name});");
        }

        if (parsedHeader.cppConsts.Count > 0)
        {
            casserts.Add("");
        }

        foreach (var e in parsedHeader.cppEnums)
        {
            foreach (var v in e.values)
            {
                var cValueName = ConvertEnumName(e.name, v.name);
                casserts.Add($"C_ASSERT({cValueName} == static_cast<uint32_t>({e.name}::{v.name}));");
            }
            casserts.Add("");
        }

        foreach (var s in parsedHeader.cppStructs)
        {
            var cStructName = ConvertMixedCaseToShoutCase(s.name);
            var unionMemberName = ConvertStateChangeCStructNameToUnionMemberName(cStructName);
            casserts.Add($"C_ASSERT(sizeof({cStructName}) == sizeof({s.name}));");

            foreach (var f in s.fields)
            {
                var cFieldName = ConvertFieldName(f.name);
                casserts.Add($"C_ASSERT(sizeof({cStructName}::{cFieldName}) == sizeof({s.name}::{f.name}));");
                casserts.Add($"C_ASSERT(offsetof({cStructName}, {cFieldName}) == offsetof({s.name}, {f.name}));");
            }
            casserts.Add("");
        }

        foreach (var type in _handlesForPointerTypes.Keys)
        {
            if ((!parsedHeader.isXblPlugin && type.Contains("PartyXbl")) || (parsedHeader.isXblPlugin && !type.Contains("PartyXbl")))
            {
                continue;
            }
            else
            {
                casserts.Add($"C_ASSERT(sizeof({_handlesForPointerTypes[type]}) == sizeof({type}*));");
            }
        }

        casserts.Add("");

        foreach (var type in _convertedTypes.Keys)
        {
            if ((!parsedHeader.isXblPlugin && type.Contains("PartyXbl")) || (parsedHeader.isXblPlugin && !type.Contains("PartyXbl")))
            {
                continue;
            }
            else
            {
                casserts.Add($"C_ASSERT(sizeof({type}) == sizeof({_convertedTypes[type]}));");
            }
        }

        casserts.Add("");

        return casserts;
    }

    List<string> ProcessHeaderForEnumStrings(ParsedCppHeader parsedHeader)
    {
        var enumStrings = new List<string>();
        foreach (var e in parsedHeader.cppEnums)
        {
            if (!e.hex)
            {
                var cShoutCaseEnumName = ConvertMixedCaseToShoutCase(e.name);
                var cEnumListName = $"{cShoutCaseEnumName}_LIST";

                enumStrings.Add("");
                enumStrings.Add($"#define {cEnumListName}() \\");

                foreach (var v in e.values)
                {
                    enumStrings.Add($"    {cEnumListName}_ITEM({v.name}) \\");
                }

                // EnumToString helpers
                enumStrings.Add("");
                enumStrings.Add($"constexpr PartyString g_{e.name}Names[] =");
                enumStrings.Add("{");
                enumStrings.Add($"#define {cEnumListName}_ITEM(name) \\");
                enumStrings.Add("    #name,");
                enumStrings.Add($"    {cEnumListName}()");
                enumStrings.Add("};");

                enumStrings.Add("");
                enumStrings.Add("PartyString");
                enumStrings.Add("PartyEnumToString(");
                enumStrings.Add($"    Party::{e.name} type");
                enumStrings.Add("    )");
                enumStrings.Add("{");
                enumStrings.Add("    int intType = EnumToIntType(type);");
                enumStrings.Add($"    if (intType < 0 || intType >= _countof(g_{e.name}Names))");
                enumStrings.Add("    {");
                enumStrings.Add("        return \"(out of range)\";");
                enumStrings.Add("    }");
                enumStrings.Add($"    return g_{e.name}Names[intType];");
                enumStrings.Add("};");
            }
        }

        return enumStrings;
    }

    List<string> ProcessHeaderForEnumStringsHeader(ParsedCppHeader parsedHeader)
    {
        var enumStrings = new List<string>();
        foreach (var e in parsedHeader.cppEnums)
        {
            if (!e.hex)
            {
                enumStrings.Add("PartyString");
                enumStrings.Add("PartyEnumToString(");
                enumStrings.Add($"    Party::{e.name} type");
                enumStrings.Add("    );");
                enumStrings.Add("");
            }
        }

        return enumStrings;
    }

    List<string> ProcessHeaderForStateChangeAddRefs(ParsedCppHeader parsedHeader)
    {
        var stateChangeAddRefs = new List<string>();

        stateChangeAddRefs.Add("");
        foreach (var s in parsedHeader.cppStructs)
        {
            var cStructName = ConvertMixedCaseToShoutCase(s.name);
            var unionMemberName = ConvertStateChangeCStructNameToUnionMemberName(cStructName);
            if (s.stateChange)
            {
                if (cStructName == "PARTY_MESSAGE_RECEIPT_RECEIVED_STATE_CHANGE")
                {
                    // this type maps to 3 different state changes
                    stateChangeAddRefs.Add($"        case PARTY_STATE_CHANGE_TYPE_MESSAGE_TRANSMIT_RECEIPT_RECEIVED:");
                    stateChangeAddRefs.Add($"        case PARTY_STATE_CHANGE_TYPE_MESSAGE_RECEIVE_RECEIPT_RECEIVED:");
                    stateChangeAddRefs.Add($"        case PARTY_STATE_CHANGE_TYPE_MESSAGE_PROCESS_RECEIPT_RECEIVED:");
                }
                else
                {
                    var typeName = ConvertStateChangeCStructNameToTypeName(cStructName);
                    stateChangeAddRefs.Add($"        case {typeName}:");
                }
            }

            foreach (var f in s.fields)
            {
                var cFieldName = ConvertFieldName(f.name);
                if (s.stateChange && _handleTypes.Contains(f.type))
                {
                    if (f.array)
                    {
                        throw new Exception($"Unhandled handle array {s.name}::{f.name}. Line: {f.line}");
                    }
                    else
                    {
                        if (f.pointerType == PointerType.None)
                        {
                            var addRefLine = $"            AddRefExternalHandleInternal(stateChange.{unionMemberName}.{cFieldName});";
                            if (f.annotation != null && f.annotation.StartsWith("_Maybenull_"))
                            {
                                stateChangeAddRefs.Add($"            if (stateChange.{unionMemberName}.{cFieldName} != nullptr)");
                                stateChangeAddRefs.Add( "            {");
                                stateChangeAddRefs.Add("    " + addRefLine);
                                stateChangeAddRefs.Add( "            }");
                            }
                            else
                            {
                                stateChangeAddRefs.Add(addRefLine);
                            }
                        }
                        else if (f.pointerType == PointerType.Single)
                        {
                            stateChangeAddRefs.Add($"            for (uint32_t i = 0; i < stateChange.{unionMemberName}.{f.sizeName}; i++)");
                            stateChangeAddRefs.Add( "            {");
                            stateChangeAddRefs.Add($"                AddRefExternalHandleInternal(stateChange.{unionMemberName}.{cFieldName}[i]);");
                            stateChangeAddRefs.Add( "            }");
                        }
                        else
                        {
                            throw new Exception($"Unhandled handle pointer {s.name}::{f.name}. Line: {f.line}");
                        }
                    }
                }
            }

            if (s.stateChange)
            {
                stateChangeAddRefs.Add($"            break;");
                stateChangeAddRefs.Add("");
            }
        }

        return stateChangeAddRefs;
    }

    List<string> ProcessHeaderForStateChangeUnion(ParsedCppHeader parsedHeader)
    {
        var stateChangeUnion = new List<string>();
        foreach (var s in parsedHeader.cppStructs)
        {
            if (s.stateChange)
            {
                var cStructName = ConvertMixedCaseToShoutCase(s.name);
                var unionMemberName = ConvertStateChangeCStructNameToUnionMemberName(cStructName);
                stateChangeUnion.Add($"        {cStructName} {unionMemberName};");
            }
        }
        return stateChangeUnion;
    }

    List<string> ProcessHeaderForDefines(ParsedCppHeader parsedHeader)
    {
        var defines = new List<string>();
        foreach (var e in parsedHeader.cppEnums)
        {
            if (e.name == "PartyStateChangeType" || e.name == "PartyXblStateChangeType")
            {
                string finalStateChangeTypeCValueName = "";
                foreach (var v in e.values)
                {
                    finalStateChangeTypeCValueName = ConvertEnumName(e.name, v.name);
                }

                if (finalStateChangeTypeCValueName == "")
                {
                    throw new Exception($"Failed to find any state change types to define c_stateChangeTypeCount");
                }

                String constantName = (parsedHeader.isXblPlugin) ? "c_xblStateChangeTypeCount" : "c_stateChangeTypeCount";

                defines.Add($"constexpr int32_t {constantName} = static_cast<int32_t>({finalStateChangeTypeCValueName}) + 1;");
                break;
            }
        }
        return defines;

    }

    void ProcessPublicHeader()
    {
        string bumblelionClientDir = Path.Combine(GetScriptDirectory(), "..");

        string bumblelionPubDir = Path.Combine(bumblelionClientDir, "pub");


        string bumblelionEnumStringsDir = Path.Combine(bumblelionClientDir, "tool", "shared", "lib");

        string bumblelionEnumStringsHeaderDir = Path.Combine(bumblelionClientDir, "tool", "shared", "inc");

        string bumblelionStateChangeManagerDir = Path.Combine(bumblelionClientDir, "api", "src");

        string bumblelionDefinesDir = Path.Combine(bumblelionClientDir, "api", "inc");

        ParsedCppHeader parsedHeader = ParseCppHeader(Path.Combine(bumblelionPubDir, "Party.h"));

        UpdateAutoGeneratedSection(Path.Combine(bumblelionPubDir, "Party_c.h"), ProcessHeaderForDeclarations(parsedHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionPubDir, "PartyImpl.h"), ProcessHeaderForCAsserts(parsedHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionEnumStringsDir, "EnumStrings.cpp"), ProcessHeaderForEnumStrings(parsedHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionEnumStringsHeaderDir, "EnumStrings.h"), ProcessHeaderForEnumStringsHeader(parsedHeader));

        List<string> stateChangeAddRefs = ProcessHeaderForStateChangeAddRefs(parsedHeader);
        List<string> stateChangeReleases = (from addRef in stateChangeAddRefs select addRef.Replace("AddRef", "Release")).ToList();
        UpdateAutoGeneratedSection(Path.Combine(bumblelionStateChangeManagerDir, "PartyStateChangeManager.cpp"), stateChangeAddRefs, "AddRef");
        UpdateAutoGeneratedSection(Path.Combine(bumblelionStateChangeManagerDir, "PartyStateChangeManager.cpp"), stateChangeReleases, "Release");

        UpdateAutoGeneratedSection(Path.Combine(bumblelionStateChangeManagerDir, "PartyStateChangeManager.h"), ProcessHeaderForStateChangeUnion(parsedHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionDefinesDir, "BumblelionDefines.h"), ProcessHeaderForDefines(parsedHeader));

        ParsedCppHeader parsedTestHeader = ParseCppHeader(Path.Combine(bumblelionPubDir, "PartyTestFeatures.h"));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionPubDir, "PartyTestFeatures_c.h"), ProcessHeaderForDeclarations(parsedTestHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionPubDir, "PartyTestFeaturesImpl.h"), ProcessHeaderForCAsserts(parsedTestHeader));


        // Xbl Plugin
        string bumblelionXblPubDir = Path.Combine(bumblelionClientDir, "..", "plugins", "xboxlive", "pub");
        string bumblelionXblSrcDir = Path.Combine(bumblelionClientDir, "..", "plugins", "xboxlive", "src");

        ParsedCppHeader parsedXblHeader = ParseCppHeader(Path.Combine(bumblelionXblPubDir, "PartyXboxLive.h"));
        parsedXblHeader.isXblPlugin = true;

        UpdateAutoGeneratedSection(Path.Combine(bumblelionXblPubDir, "PartyXboxLive_c.h"), ProcessHeaderForDeclarations(parsedXblHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionXblPubDir, "PartyXboxLiveImpl.h"), ProcessHeaderForCAsserts(parsedXblHeader));

        List<string> xblStateChangeAddRefs = ProcessHeaderForStateChangeAddRefs(parsedXblHeader);
        List<string> xblStateChangeReleases = (from addRef in xblStateChangeAddRefs select addRef.Replace("AddRef", "Release")).ToList();
        UpdateAutoGeneratedSection(Path.Combine(bumblelionXblSrcDir, "XblStateChangeManager.cpp"), xblStateChangeAddRefs, "AddRef");
        UpdateAutoGeneratedSection(Path.Combine(bumblelionXblSrcDir, "XblStateChangeManager.cpp"), xblStateChangeReleases, "Release");

        UpdateAutoGeneratedSection(Path.Combine(bumblelionXblSrcDir, "XblStateChangeManager.h"), ProcessHeaderForStateChangeUnion(parsedXblHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionXblSrcDir, "XblDefines.h"), ProcessHeaderForDefines(parsedXblHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionEnumStringsDir, "XblEnumStrings.cpp"), ProcessHeaderForEnumStrings(parsedXblHeader));
        UpdateAutoGeneratedSection(Path.Combine(bumblelionEnumStringsHeaderDir, "XblEnumStrings.h"), ProcessHeaderForEnumStringsHeader(parsedXblHeader));

    }

    void VerifyQualityOfFile(string file)
    {
        // ignore external files
        if (file.Contains(@"bumblelion\external"))
        {
            return;
        }

        var logTypes = new HashSet<string>();
        var lockTypes = new HashSet<string>();
        var lines = File.ReadAllLines(file);
        foreach (var line in lines)
        {
            var match = Regex.Match(line, @"^\s+DbgLog\w*\((\w+),");
            if (match.Success)
            {
                logTypes.Add(match.Groups[1].Value);
            }
            else
            {
                match = Regex.Match(line, @"^\s*_Requires_(\w+Lock)_");
                if (match.Success)
                {
                    lockTypes.Add(match.Groups[1].Value);
                }
            }
        }

        var logTypesArray = logTypes.ToArray();
        if (logTypes.Count > 1)
        {
            if (logTypes.Count > 2 ||
                (logTypes.Count == 2 && logTypesArray[0] != logTypesArray[1] + "_VERBOSE" && logTypesArray[1] != logTypesArray[0] + "_VERBOSE"))
            {
                Console.WriteLine($"WARNING: {file} has multiple logging types");
                Console.WriteLine(string.Join(",", logTypesArray));
            }
        }

        if (lockTypes.Count > 1)
        {
            Console.WriteLine($"WARNING: {file} has multiple lock types");
            Console.WriteLine(string.Join(",", lockTypes.ToArray()));
        }
    }

    void VerifyQualityOfFiles()
    {
        string bumblelionDir = Path.Combine(GetScriptDirectory(), "..", "..");

        var files = Directory.EnumerateFiles(bumblelionDir, "*.cpp", SearchOption.AllDirectories).ToList();
        files.AddRange(Directory.EnumerateFiles(bumblelionDir, "*.h", SearchOption.AllDirectories));
        foreach (var file in files)
        {
            Console.WriteLine(file);
            VerifyQualityOfFile(file);
        }
    }

    static void Usage()
    {
        Console.WriteLine("UpdateHeaders - generate code based on the public header");
        Console.WriteLine("Usage:");
        Console.WriteLine("  csi UpdateHeaders.csx");
        Console.WriteLine("    Update the various headers and code based on the public C++ header");
        Console.WriteLine("  csi UpdateHeaders.csx --quality");
        Console.WriteLine("    Check all .h/.cpp files for quality issues");
    }

    public static int Main(string[] args)
    {
        var program = new Program();
        if (args.Length > 0)
        {
            if (args[0] == "--quality")
            {
                program.VerifyQualityOfFiles();
            }
            else
            {
                Usage();
            }
        }
        else
        {
            program.ProcessPublicHeader();
        }

        return 0;
    }
}

Program.Main(Args.ToArray());
