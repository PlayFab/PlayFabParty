// This script generates an external mapping of our internal bumblelion error codes to their human readable string
// forms.
//
// Usage: csi .\UpdateErrorDocumentation.csx

#load "AutoGenerate.csx" // UpdateAutoGeneratedSection

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

using System.Runtime.CompilerServices;
static string GetScriptDirectory([CallerFilePath] string path = "")
{
    return Path.GetDirectoryName(path);
}

public class ErrorDocumentationGenerator
{
    readonly static string partySourceRootPath = Path.Combine(GetScriptDirectory(), "..", "..");
    readonly static string partyRootPath = Path.Combine(partySourceRootPath, "..", "..");

    public static int Main(string[] args)
    {
        string bumblelionErrorsHeaderFileName = Path.Combine(partySourceRootPath, "client", "api", "inc", "BumblelionErrors.h");

        List<string> linesToWrite = new List<string>();
        List<string> errorConstants = new List<string>();
        bool inInternalRange = true;
        foreach (var line in File.ReadAllLines(bumblelionErrorsHeaderFileName))
        {
            var errorValueMatch = Regex.Match(line, @"error_(\w+)\((0x\w+), (\w+), ""(.*)""");
            if (errorValueMatch.Success)
            {
                string errorConstant = errorValueMatch.Groups[3].ToString();
                errorConstants.Add(errorConstant);

                if (errorValueMatch.Groups[1].ToString() == "ext")
                {
                    if (inInternalRange)
                    {
                        throw new Exception("External error should not be in an internal range");
                    }
                    string errorCode = errorValueMatch.Groups[2].ToString();
                    string errorMessage = ToSentenceCase(errorValueMatch.Groups[4].ToString()) + ".";
                    linesToWrite.Add($"{errorCode} | {errorMessage}");
                }
                continue;
            }

            var errorRangeMatch = Regex.Match(line, @"/\* (\S+) ERRORS: \(.*\) (\S+) \*/");
            if (errorRangeMatch.Success)
            {
                string visibility = errorRangeMatch.Groups[2].ToString();
                if (visibility != "INTERNAL" && visibility != "EXTERNAL")
                {
                    throw new Exception("Visibility must be INTERNAL or EXTERNAL");
                }

                inInternalRange = visibility == "INTERNAL";
                if (!inInternalRange)
                {
                    string errorRangeName = ToSentenceCase(errorRangeMatch.Groups[1].ToString().ToLower());
                    linesToWrite.Add("");
                    linesToWrite.Add($"## {errorRangeName} errors");
                    linesToWrite.Add("Number | Description");
                    linesToWrite.Add("------ | ------");
                }
            }
        }

        UpdateAutoGeneratedSection(Path.Combine(partySourceRootPath, "client", "pub", "PartyErrors.md"), linesToWrite);

        var xrnToBumblelionErrorMap = GenerateXrnErrorMap(errorConstants);
        UpdateXrnErrorMappingFunction(xrnToBumblelionErrorMap);

        CheckNoStaleErrorConstants(errorConstants);
        return 0;
    }

    static string ToSentenceCase(string s)
    {
        return s.Substring(0, 1).ToUpper() + s.Substring(1);
    }

    static Dictionary<string, string> GenerateXrnErrorMap(List<string> errorConstants)
    {
        string xrnErrorsFilePath = Path.Combine(partyRootPath, "external", "xrn", "inc", "XrnErrors.h");

        Dictionary<string, string> xrnToBumblelionErrorMap = new Dictionary<string, string>();

        HashSet<string> ignoredXrnErrors = new HashSet<string>()
        {
            "XRN_E_SESSIONFULL",
            "XRN_E_PARTIALCONNECTIVITY",
            "XRN_E_DISJOINTCONNECTIVITY"
        };
        List<string> xrnErrors = new List<string>();
        foreach (var line in File.ReadAllLines(xrnErrorsFilePath))
        {
            // Be sure to match with the trailing MAKE_XRNRESULTERROR to avoid success codes and E_OUTOFMEMORY
            var xrnErrorMatch = Regex.Match(line, @"#define (XRN_E_\w+)\s+MAKE_XRNRESULTERROR");
            if (xrnErrorMatch.Success)
            {
                string xrnError = xrnErrorMatch.Groups[1].ToString();
                if (ignoredXrnErrors.Contains(xrnError))
                {
                    Console.WriteLine($"Ignoring XRN error: {xrnError}!");
                }
                else
                {
                    xrnErrors.Add(xrnError);
                }
            }
        }

        const string xrnPrefix = "XRN_E_";
        const string bumblelionPrefix = "c_bumblelionErrorXrn";

        bool allErrorsFound = true;
        foreach (string xrnError in xrnErrors)
        {
            string strippedXrnError = xrnError.Substring(xrnPrefix.Length).ToLower();
            string expectedBumblelionError = (bumblelionPrefix + strippedXrnError).ToLower();

            bool foundError = false;
            foreach (string bumblelionError in errorConstants)
            {
                if (expectedBumblelionError == bumblelionError.ToLower())
                {
                    foundError = true;
                    xrnToBumblelionErrorMap[xrnError] = bumblelionError;
                    break;
                }
            }

            if (!foundError)
            {
                Console.WriteLine($"WARNING: failed to find bumblelion error to match XRN error {xrnError}! Expected to case insensitively match an error named {expectedBumblelionError}!");
                allErrorsFound = false;
            }
        }

        if (!allErrorsFound)
        {
            throw new Exception("Failed to map all xrn errors to bumblelion errors");
        }

        return xrnToBumblelionErrorMap;
    }

    static void UpdateXrnErrorMappingFunction(Dictionary<string, string> xrnErrorMap)
    {
        List<string> xrnToBumblelionErrorSwitchCases = new List<string>();
        foreach(var entry in xrnErrorMap)
        {
            xrnToBumblelionErrorSwitchCases.Add($"        case {entry.Key}:");
            xrnToBumblelionErrorSwitchCases.Add($"            RETURN({entry.Value});");
        }
        UpdateAutoGeneratedSection(
            Path.Combine(partySourceRootPath, "common", "pal", "lib", "CofaErrorHelpers.cpp"),
            xrnToBumblelionErrorSwitchCases);
    }

    static void CheckNoStaleErrorConstants(List<string> errorConstants)
    {
        FindStaleErrors(errorConstants, partySourceRootPath);

        Console.ForegroundColor = ConsoleColor.Red;
        foreach (var staleConstant in errorConstants)
        {
            Console.WriteLine($"Failed to find PartyError, {staleConstant}, in any Party source file!");
        }
        Console.ResetColor();
    }

    static void FindStaleErrors(List<string> errors, string parentDir)
    {
        foreach (var dir in Directory.GetDirectories(parentDir))
        {
            if (dir.Contains("external"))
            {
                continue;
            }

            foreach (var file in Directory.GetFiles(dir))
            {
                if (file.Contains("BumblelionErrors.h"))
                {
                    continue;
                }

                if (!file.Contains(".cpp") && !file.Contains(".h"))
                {
                    continue;
                }

                var linesInFile = File.ReadAllLines(file);
                for (int i = 0; i < linesInFile.Count(); i++)
                {
                    errors.RemoveAll(error => linesInFile[i].Contains(error));
                }
            }

            // recurse
            FindStaleErrors(errors, dir);
        }
    }
}

ErrorDocumentationGenerator.Main(Args.ToArray());
